---
title: "Cell Line Application"
author: "Alexander Dombowsky"
date: "11/10/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sn)
library(ggplot2)
library(mcclust)
library(mcclust.ext)
library(mclust)
library(grid)
library(gridExtra)
library(Rcpp)
library(RcppArmadillo)
library(plyr)
library(dplyr)
library(reshape2)
library(mvtnorm)
library(scran)
library(scuttle)
library(M3Drop)
library(latex2exp)
library(cowplot)
```

# Introduction
This is the application of FOLD to the GSE81861 dataset. A version of the data is given in the "data" folder on the repository. First, we will pre-process the data, then reduce the dimension to five principal components. We will then fit a Bayesian Gaussian mixture and apply the EM algorithm to get clusterings from FOLD, VI, and \texttt{mclust}. For the FOLD clustering, we also compute a credible ball. 

# Loading and Pre-Processing
```{r}
cells_csv <- read.csv("data/cells.csv")
cells <- as.matrix(cells_csv[,-1])
# remove dimnames
cells <- SingleCellExperiment(list(counts=cells))
# remove low count cells
qcstats <- perCellQCMetrics(cells)
qcfilter <- quickPerCellQC(qcstats) # come back to
cells <- cells[,!qcfilter$discard]
# perform SCRAN normalization
clusters <- quickCluster(cells)
cells <- computeSumFactors(cells, clusters=clusters)
cells <- logNormCounts(cells, log = T) 
data <- cells@assays@data@listData$logcounts
norm_data <- M3DropConvertData(data,
                               is.log = T)
norm_data <- as.data.frame(norm_data)
cellnames <- colnames(norm_data)
norm_data <- unname(norm_data)
drop_data <- M3DropFeatureSelection(norm_data, mt_method="fdr", mt_threshold=0.01)
genes <- drop_data$Gene
data <- norm_data[genes,]
n <- ncol(data)
# configuring names
dictionary <- c("_A549_","_GM12878_", "_H1437_", "_HCT116_", "_IMR90_", "_H1_", "_K562_")
K <- length(dictionary)
types <- matrix(0, nrow = n, ncol = K)
for (k in 1:K) {
  types[,k] <- k * grepl(dictionary[k], cellnames)
}
types <- rowSums(types)

# taking PCA
d <- 5
dpc <- prcomp(t(data), rank. = d, scale. = T)
X <- scale(dpc$x)
```

# running MCMC
```{r}
source("rfuncts/mvnorm_gibbs.R")
source("rfuncts/mnorm_D_apply.R")
source("rfuncts/foldball.R")
sourceCpp("rcppfuncts/mnorm_D_arma.cpp")
S <- 25000 # iterations
B <- 1000 # burnin
L <- 50 # components
# fitting a Bayesian Gaussian mixture
fit <- mvnorm_gibbs(S = S,
                    y = X,
                    L = L,
                    alpha = rep(1/2,L), 
                    w = rep(0,d),
                    kappa = 1,
                    r = d+2,
                    C = diag(1,d),
                    stops = 1000)
# burnin
theta <- fit$theta[-(1:B)]
M <- length(theta)
n <- nrow(X)
theta <- array(unlist(theta), dim = c(n, 2*d + choose(d,2), M))
z <- fit$z[-(1:B),]
# thin
trip_ind <- seq(4,M,by=4)
theta <- theta[,,trip_ind]
z <- z[trip_ind,]
# apply hellinger distance function
Delta_UT <- makeHellingerAvg(theta = theta, d = d, n = n)
Delta <- matrix(0, nrow = n, ncol = n)
Delta[upper.tri(Delta)] <- Delta_UT
Delta <- Delta + t(Delta)
Delta_H <- Delta
# choose candidate set
source("rfuncts/mergeloss.R")
Delta <- as.dist(Delta)
cl <- hclust(Delta, method = "average") # uses hierarchical clustering to get candidate set
# list of possible clusterings
max.k <- 24  # maximum number of clusters
labs <- matrix(0, nrow = max.k, ncol = n)
for (h in 1:max.k){
  labs[h,] = cutree(cl, k = h)
}
# VI loss
c.psm <- comp.psm(z)
c.mv <- minVI(psm = c.psm,
              cls.draw = z,
              max.k = max.k)
c.VI <- c.mv$cl
# Binder's Loss
c.b <- minbinder(psm = c.psm,
              cls.draw = z,
              max.k = max.k)
c.Binder <- c.b$cl
# Elbow Plot
W <- seq(0,250,by=2)
tv <- c()
tv <- c()
h_bar <- sum(Delta_H[lower.tri(Delta_H)])
for (k in 1:max.k){
  wss <- c()
  for (h in 1:k) {
    Delta_h <- Delta_H[labs[k,]==h, labs[k,]==h]
    wss[h] <- sum(Delta_h[lower.tri(Delta_h)])
  }
  tv[k] <- sum(wss)/h_bar
}
elb_df <- data.frame(Size = 1:max.k,
                     TV = tv)
ggplot(elb_df, aes(x = Size, y  = TV)) + geom_line() + geom_point() + 
  labs(title = "Elbow Plot") +
  xlab("No. of Clusters") +
  ylab(latex2exp::TeX("$r_{\\omega}$")) +
  scale_x_discrete(limits = as.character(1:max.k)) +
  theme_bw() +
  theme(text = element_text(size=18))
c.fold = labs[6,] # bend of the elbow
# Mclust
mcl <- Mclust(X, G = 1:24)
# plot with UMAP
set.seed(2001)
umapped_cells <- uwot::umap(t(data), 
                            min_dist = 0.8)
types <- as.factor(types)
levels(types) <- c("A5A9", "GM12878", "H1437", "HCT116",
                   "IMR90", "H1", "K562")
umapped_df <- data.frame(umapped_cells,
                         c.VI = factor(c.VI),
                         c.Binder <- factor(c.Binder),
                         c.Mclust= factor(mcl$classification),
                         c.fold = factor(c.fold),
                         types = factor(types))
colnames(umapped_df)[1:2] <- c("UMAP1", "UMAP2")
gg_truth <- umapped_df %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = types)) + geom_point() + 
  labs(caption = "The true cell types.", color = "Types", title = " ") + theme_bw() +
  theme(
    #axis.line = element_blank(),
    #    axis.ticks = element_blank(),
    #    axis.text = element_blank(),
        text = element_text(size=14),
        plot.background = element_blank(),
        plot.caption = element_text(hjust=0.5)
    #    panel.grid.major = element_blank(),
    #    panel.grid.minor = element_blank(),
    #    panel.border = element_blank()
    )
gg_VI <- umapped_df %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = c.VI)) + geom_point() + 
  labs(caption = "Clusters given by minimizing the VI loss.", color = "Cluster", title = " ") + theme_bw() +
  theme(
    #axis.line = element_blank(),
    #    axis.ticks = element_blank(),
    #    axis.text = element_blank(),
        text = element_text(size=14),
        plot.background = element_blank(),
        plot.caption = element_text(hjust=0.5)
    #    panel.grid.major = element_blank(),
    #    panel.grid.minor = element_blank(),
    #    panel.border = element_blank()
    )
gg_mclust <- umapped_df %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = c.Mclust)) + geom_point() + 
  labs(caption = "Clusters given by Mclust.", color = "Cluster", title = " ") + theme_bw() +
  theme(
    #axis.line = element_blank(),
    #    axis.ticks = element_blank(),
    #    axis.text = element_blank(),
        text = element_text(size=14),
        plot.background = element_blank(),
        plot.caption = element_text(hjust=0.5)
    #    panel.grid.major = element_blank(),
    #    panel.grid.minor = element_blank(),
    #    panel.border = element_blank()
    )
gg_fold <- umapped_df %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = c.fold)) + geom_point() + 
  labs(caption = latex2exp::TeX("$\\textbf{c}_{\\textrm{FOLD}}.$"), color = "Cluster", title = " ") + theme_bw() +
  theme(
    #axis.line = element_blank(),
    #    axis.ticks = element_blank(),
    #    axis.text = element_blank(),
        text = element_text(size=14),
        plot.background = element_blank(),
        plot.caption = element_text(hjust=0.5)
    #    panel.grid.major = element_blank(),
    #    panel.grid.minor = element_blank(),
    #    panel.border = element_blank()
    )
plot_grid(gg_truth, gg_fold, gg_VI, gg_mclust, labels = c('(a)', '(b)', '(c)', '(d)'))
# credible ball and cGPSM
cgsamps <- getcGsamps(theta=theta, w=25, d=5, max.k=10)
cb <- cGball(c.fold,cgsamps)
foldpsm <- cGpsm(cgsamps)
# plot PSM
c.fold.ordered <- order(c.fold)
fpsm.ordered <- foldpsm[c.fold.ordered, c.fold.ordered]
melt.psm <- melt(fpsm.ordered)
fpsm = ggplot(data = melt.psm, aes(x = Var1, y = rev(Var2), fill = value)) +
  geom_tile() + scale_fill_distiller(palette = "YlOrBr") +
  xlab("") + ylab("") + labs(title = "Posterior Similiarity Matrix",
                             fill = TeX("$\\Pi(s_i = s_j | X)$")) +
    theme_bw() + 
  theme(axis.line = element_blank(),
    legend.position = "right",
    axis.ticks = element_blank(),
    axis.text = element_blank(),
    plot.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank())
# credible ball partitions
ball.df <- data.frame(
  umapped_cells,
  cfold = factor(c.fold),
  choriz = factor(cb$c.horiz[1,]),
  c.upperv = factor(cb$c.uppervert[1,]),
  c.lowerv = factor(cb$c.lowervert[1,]))
foldumap <- ggplot(ball.df, aes(x = X1, y = X2, color = cfold)) + geom_point() + labs(color = "Cluster", caption = latex2exp::TeX("The point estimator, $\\textbf{c}_{\\textrm{FOLD}}.$"), 
                                                                                      title = " ")  +
xlab("UMAP1") + ylab("UMAP2") +
  theme_bw() + 
  #scale_color_brewer(palette="Dark2")+
  theme(
    #axis.line = element_blank(),
    #    axis.ticks = element_blank(),
    #    axis.text = element_blank(),
        text = element_text(size=14),
        plot.background = element_blank(),
        plot.caption = element_text(hjust = 0.5)
    #    panel.grid.major = element_blank(),
    #    panel.grid.minor = element_blank(),
    #    panel.border = element_blank()
    ) 
horizumap <- ggplot(ball.df, aes(x = X1, y = X2, color = choriz)) + geom_point() + labs(caption="95% credible ball horizontal bound.", color = "Cluster", 
                                                                                        title = " ") +
xlab("UMAP1") + ylab("UMAP2") +
  theme_bw() + 
  #scale_color_brewer(palette="Dark2")+
  theme(
    #axis.line = element_blank(),
    #    axis.ticks = element_blank(),
    #    axis.text = element_blank(),
        text = element_text(size=14),
        plot.background = element_blank(),
        plot.caption = element_text(hjust = 0.5)
    #    panel.grid.major = element_blank(),
    #    panel.grid.minor = element_blank(),
    #    panel.border = element_blank()
    )
uppervumap <- ggplot(ball.df, aes(x = X1, y = X2, color = c.upperv)) + geom_point() + labs(caption="95% credible ball vertical upper bound.", color = "Cluster",
                                                                                           title = " ")  +
xlab("UMAP1") + ylab("UMAP2") +
  theme_bw() + 
  #scale_color_brewer(palette="Dark2")+
  theme(
    #axis.line = element_blank(),
    #    axis.ticks = element_blank(),
    #    axis.text = element_blank(),
        text = element_text(size=14),
        plot.background = element_blank(),
        plot.caption = element_text(hjust = 0.5)
    #    panel.grid.major = element_blank(),
    #    panel.grid.minor = element_blank(),
    #    panel.border = element_blank()
    )
lowervumap <- ggplot(ball.df, aes(x = X1, y = X2, color = c.lowerv)) + geom_point() + labs(caption="95% credible ball vertical lower bound.", color = "Cluster", title = " ")  +
xlab("UMAP1") + ylab("UMAP2") +
  theme_bw() + 
  #scale_color_brewer(palette="Dark2")+
  theme(
    #axis.line = element_blank(),
    #    axis.ticks = element_blank(),
    #    axis.text = element_blank(),
        text = element_text(size=14),
        plot.background = element_blank(),
        plot.caption = element_text(hjust = 0.5)
    #    panel.grid.major = element_blank(),
    #    panel.grid.minor = element_blank(),
    #    panel.border = element_blank()
    )
# arranging into a grid
plot_grid(foldumap, horizumap, lowervumap, uppervumap, labels = c('(a)', '(b)', '(c)', '(d)'))
```